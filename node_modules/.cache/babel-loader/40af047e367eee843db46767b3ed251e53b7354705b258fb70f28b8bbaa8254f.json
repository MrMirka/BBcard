{"ast":null,"code":"/* eslint-disable */\nimport { AdditiveBlending, BufferAttribute, BufferGeometry, Group, Points, ShaderMaterial } from 'three';\nimport { generateStarTexture } from './texture';\nimport { RESOLUTION } from '../CardBoxInstance';\nconst vertexShader = `\nattribute float size;\nuniform float u_position;\n\nvoid main() {\n  vec3 startPosition = position;\n  startPosition.y = startPosition.y - (1.0 - u_position) * 1.5;\n  startPosition.x = startPosition.x * u_position;\n  vec4 mvPosition = modelViewMatrix * vec4( startPosition, 1.0 );\n\n  gl_PointSize = size * ( 2.0 / -mvPosition.z );\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n`;\nconst fragmentShader = `\nuniform sampler2D u_texture;\nuniform float u_opacity;\n\nvoid main() {\n  vec2 uv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );\n\n  gl_FragColor = texture2D( u_texture, uv );\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\n}\n`;\nexport const generateStars = () => {\n  const num = 400;\n  const w = 2;\n  const h = 2;\n  const positions = new Float32Array(num * 3);\n  const sizes = new Float32Array(num);\n  const rand = () => 0.5 - Math.random();\n  for (let i = 0; i < num; i++) {\n    const v0 = i * 3;\n    const v1 = v0 + 1;\n    const v2 = v0 + 2;\n    positions[v0] = rand() * w;\n    positions[v1] = rand() * h;\n    positions[v2] = rand() * (h / 2 - 10);\n    sizes[i] = (5 + Math.random() * 10) * RESOLUTION;\n  }\n  const geometry = new BufferGeometry();\n  geometry.setAttribute('position', new BufferAttribute(positions, 3));\n  geometry.setAttribute('size', new BufferAttribute(sizes, 1));\n  const material = new ShaderMaterial({\n    uniforms: {\n      u_texture: {\n        value: generateStarTexture()\n      },\n      u_opacity: {\n        value: 0\n      },\n      u_position: {\n        value: 0.5\n      }\n    },\n    // fog: true,\n    transparent: true,\n    depthTest: false,\n    depthWrite: false,\n    // side: DoubleSide,\n    blending: AdditiveBlending,\n    vertexShader,\n    fragmentShader\n  });\n  const particles = new Points(geometry, material);\n  const group = new Group();\n  group.add(particles);\n  return {\n    geometry,\n    material,\n    particles,\n    group\n  };\n};","map":{"version":3,"names":["AdditiveBlending","BufferAttribute","BufferGeometry","Group","Points","ShaderMaterial","generateStarTexture","RESOLUTION","vertexShader","fragmentShader","generateStars","num","w","h","positions","Float32Array","sizes","rand","Math","random","i","v0","v1","v2","geometry","setAttribute","material","uniforms","u_texture","value","u_opacity","u_position","transparent","depthTest","depthWrite","blending","particles","group","add"],"sources":["/Users/fredgan/Documents/Projects/BetBoom/Card/card/src/CardBox/instance/stars/Stars.ts"],"sourcesContent":["/* eslint-disable */\nimport {AdditiveBlending, BufferAttribute, BufferGeometry, Color, Group, Points, ShaderMaterial} from 'three';\nimport {generateStarTexture} from './texture';\nimport {RESOLUTION} from '../CardBoxInstance';\n\nconst vertexShader = `\nattribute float size;\nuniform float u_position;\n\nvoid main() {\n  vec3 startPosition = position;\n  startPosition.y = startPosition.y - (1.0 - u_position) * 1.5;\n  startPosition.x = startPosition.x * u_position;\n  vec4 mvPosition = modelViewMatrix * vec4( startPosition, 1.0 );\n\n  gl_PointSize = size * ( 2.0 / -mvPosition.z );\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n`;\nconst fragmentShader = `\nuniform sampler2D u_texture;\nuniform float u_opacity;\n\nvoid main() {\n  vec2 uv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );\n\n  gl_FragColor = texture2D( u_texture, uv );\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\n}\n`;\n\n\nexport const generateStars = () => {\n  const num = 400;\n  const w = 2;\n  const h = 2;\n\n  const positions = new Float32Array(num * 3);\n  const sizes = new Float32Array(num);\n\n  const rand = () => 0.5 - Math.random();\n\n  for (let i = 0; i < num; i++) {\n    const v0 = i * 3;\n    const v1 = v0 + 1;\n    const v2 = v0 + 2;\n\n    positions[v0] = rand() * w;\n    positions[v1] = rand() * h;\n    positions[v2] = rand() * (h / 2 - 10);\n\n    sizes[i] = (5 + Math.random() * 10) * RESOLUTION;\n  }\n\n  const geometry = new BufferGeometry();\n  geometry.setAttribute('position', new BufferAttribute(positions, 3));\n  geometry.setAttribute('size',     new BufferAttribute(sizes, 1));\n\n  const material = new ShaderMaterial({\n    uniforms: {\n      u_texture: {\n        value: generateStarTexture()\n      },\n      u_opacity: {\n        value: 0\n      },\n      u_position: {\n        value: 0.5\n      }\n    },\n    // fog: true,\n    transparent: true,\n    depthTest: false,\n    depthWrite: false,\n    // side: DoubleSide,\n    blending: AdditiveBlending,\n    vertexShader,\n    fragmentShader\n  });\n\n  const particles = new Points(geometry, material);\n  const group = new Group();\n  group.add(particles);\n\n  return {\n    geometry,\n    material,\n    particles,\n    group\n  }\n}"],"mappings":"AAAA;AACA,SAAQA,gBAAgB,EAAEC,eAAe,EAAEC,cAAc,EAASC,KAAK,EAAEC,MAAM,EAAEC,cAAc,QAAO,OAAO;AAC7G,SAAQC,mBAAmB,QAAO,WAAW;AAC7C,SAAQC,UAAU,QAAO,oBAAoB;AAE7C,MAAMC,YAAY,GAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,MAAMC,cAAc,GAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAGD,OAAO,MAAMC,aAAa,GAAGA,CAAA,KAAM;EACjC,MAAMC,GAAG,GAAG,GAAG;EACf,MAAMC,CAAC,GAAG,CAAC;EACX,MAAMC,CAAC,GAAG,CAAC;EAEX,MAAMC,SAAS,GAAG,IAAIC,YAAY,CAACJ,GAAG,GAAG,CAAC,CAAC;EAC3C,MAAMK,KAAK,GAAG,IAAID,YAAY,CAACJ,GAAG,CAAC;EAEnC,MAAMM,IAAI,GAAGA,CAAA,KAAM,GAAG,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC;EAEtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,GAAG,EAAES,CAAC,EAAE,EAAE;IAC5B,MAAMC,EAAE,GAAGD,CAAC,GAAG,CAAC;IAChB,MAAME,EAAE,GAAGD,EAAE,GAAG,CAAC;IACjB,MAAME,EAAE,GAAGF,EAAE,GAAG,CAAC;IAEjBP,SAAS,CAACO,EAAE,CAAC,GAAGJ,IAAI,CAAC,CAAC,GAAGL,CAAC;IAC1BE,SAAS,CAACQ,EAAE,CAAC,GAAGL,IAAI,CAAC,CAAC,GAAGJ,CAAC;IAC1BC,SAAS,CAACS,EAAE,CAAC,GAAGN,IAAI,CAAC,CAAC,IAAIJ,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;IAErCG,KAAK,CAACI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAIZ,UAAU;EAClD;EAEA,MAAMiB,QAAQ,GAAG,IAAItB,cAAc,CAAC,CAAC;EACrCsB,QAAQ,CAACC,YAAY,CAAC,UAAU,EAAE,IAAIxB,eAAe,CAACa,SAAS,EAAE,CAAC,CAAC,CAAC;EACpEU,QAAQ,CAACC,YAAY,CAAC,MAAM,EAAM,IAAIxB,eAAe,CAACe,KAAK,EAAE,CAAC,CAAC,CAAC;EAEhE,MAAMU,QAAQ,GAAG,IAAIrB,cAAc,CAAC;IAClCsB,QAAQ,EAAE;MACRC,SAAS,EAAE;QACTC,KAAK,EAAEvB,mBAAmB,CAAC;MAC7B,CAAC;MACDwB,SAAS,EAAE;QACTD,KAAK,EAAE;MACT,CAAC;MACDE,UAAU,EAAE;QACVF,KAAK,EAAE;MACT;IACF,CAAC;IACD;IACAG,WAAW,EAAE,IAAI;IACjBC,SAAS,EAAE,KAAK;IAChBC,UAAU,EAAE,KAAK;IACjB;IACAC,QAAQ,EAAEnC,gBAAgB;IAC1BQ,YAAY;IACZC;EACF,CAAC,CAAC;EAEF,MAAM2B,SAAS,GAAG,IAAIhC,MAAM,CAACoB,QAAQ,EAAEE,QAAQ,CAAC;EAChD,MAAMW,KAAK,GAAG,IAAIlC,KAAK,CAAC,CAAC;EACzBkC,KAAK,CAACC,GAAG,CAACF,SAAS,CAAC;EAEpB,OAAO;IACLZ,QAAQ;IACRE,QAAQ;IACRU,SAAS;IACTC;EACF,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}