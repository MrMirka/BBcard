{"ast":null,"code":"/* eslint-disable */import{ExtrudeGeometry,Shape,ShapeGeometry}from'three';export class RoundedCubeGeometry extends ExtrudeGeometry{constructor(width,height,depth,radius0,radius1,smoothness){const shape=new Shape();const eps=0.00001;const radius=radius0-eps;shape.absarc(eps,eps,eps,-Math.PI/2,-Math.PI,true);shape.absarc(eps,height-radius*2,eps,Math.PI,Math.PI/2,true);shape.absarc(width-radius*2,height-radius*2,eps,Math.PI/2,0,true);shape.absarc(width-radius*2,eps,eps,0,-Math.PI/2,true);super(shape,{depth:depth-radius1*2,bevelEnabled:true,bevelSegments:smoothness*2,steps:1,bevelSize:radius,bevelThickness:radius1,curveSegments:smoothness});this.center();}}export class RoundedPlaneGeometry extends ShapeGeometry{constructor(width,height,radius){let x=arguments.length>3&&arguments[3]!==undefined?arguments[3]:(1-width)/2;let y=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;// const x = -width / 2;\n// const y = -height / 2;\nconst shape=new Shape();shape.moveTo(x,y+radius);shape.lineTo(x,y+height-radius);shape.quadraticCurveTo(x,y+height,x+radius,y+height);shape.lineTo(x+width-radius,y+height);shape.quadraticCurveTo(x+width,y+height,x+width,y+height-radius);shape.lineTo(x+width,y+radius);shape.quadraticCurveTo(x+width,y,x+width-radius,y);shape.lineTo(x+radius,y);shape.quadraticCurveTo(x,y,x,y+radius);super(shape);}}// export const transformUV = (mesh: Mesh) => {\n//   const box = new Box3().setFromObject(mesh);\n//   const size = new Vector3();\n//   box.getSize(size);\n//   const vec3 = new Vector3(); // temp vector\n//   const attPos = mesh.geometry.attributes.position as BufferAttribute;\n//   const attUv = mesh.geometry.attributes.uv as BufferAttribute;\n//   for (let i = 0; i < attPos.count; i++){\n//     vec3.fromBufferAttribute(attPos, i);\n//     attUv.setXY(i,\n//       (vec3.x - box.min.x) / size.x,\n//       (vec3.y - box.min.y) / size.y\n//     );\n//   }\n//   const points = mesh.geometry.get\n//\n// // turn vectors' values to a typed array\n//   const bufferPoints: number[] = [];\n//   points.slice().forEach( p => {\n//     bufferPoints.push(p.x, p.y, p.z);\n//   });\n//   const F32A = new Float32Array(bufferPoints);\n//   attPos.set(F32A, 0);\n// }","map":{"version":3,"names":["ExtrudeGeometry","Shape","ShapeGeometry","RoundedCubeGeometry","constructor","width","height","depth","radius0","radius1","smoothness","shape","eps","radius","absarc","Math","PI","bevelEnabled","bevelSegments","steps","bevelSize","bevelThickness","curveSegments","center","RoundedPlaneGeometry","x","arguments","length","undefined","y","moveTo","lineTo","quadraticCurveTo"],"sources":["/Users/fredgan/Documents/Projects/BetBoom/BBCard/src/CardBox/instance/Rounded.ts"],"sourcesContent":["/* eslint-disable */\nimport {ExtrudeGeometry, Shape, ShapeGeometry} from 'three';\n\n\nexport class RoundedCubeGeometry extends ExtrudeGeometry {\n  constructor(width: number, height: number, depth: number, radius0: number, radius1: number, smoothness: number) {\n    const shape = new Shape();\n    const eps = 0.00001;\n    const radius = radius0 - eps;\n\n    shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);\n    shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);\n    shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);\n    shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);\n\n    super(shape, {\n      depth: depth - radius1 * 2,\n      bevelEnabled: true,\n      bevelSegments: smoothness * 2,\n      steps: 1,\n      bevelSize: radius,\n      bevelThickness: radius1,\n      curveSegments: smoothness\n    });\n\n    this.center();\n  }\n}\n\nexport class RoundedPlaneGeometry extends ShapeGeometry{\n  constructor(width: number, height: number, radius: number, x = (1 - width) / 2, y = 0) {\n    // const x = -width / 2;\n    // const y = -height / 2;\n\n    const shape = new Shape();\n    shape.moveTo( x, y + radius );\n    shape.lineTo( x, y + height - radius );\n    shape.quadraticCurveTo( x, y + height, x + radius, y + height );\n    shape.lineTo( x + width - radius, y + height );\n    shape.quadraticCurveTo( x + width, y + height, x + width, y + height - radius );\n    shape.lineTo( x + width, y + radius );\n    shape.quadraticCurveTo( x + width, y, x + width - radius, y );\n    shape.lineTo( x + radius, y );\n    shape.quadraticCurveTo( x, y, x, y + radius );\n\n    super(shape);\n  }\n}\n\n// export const transformUV = (mesh: Mesh) => {\n//   const box = new Box3().setFromObject(mesh);\n//   const size = new Vector3();\n//   box.getSize(size);\n//   const vec3 = new Vector3(); // temp vector\n//   const attPos = mesh.geometry.attributes.position as BufferAttribute;\n//   const attUv = mesh.geometry.attributes.uv as BufferAttribute;\n//   for (let i = 0; i < attPos.count; i++){\n//     vec3.fromBufferAttribute(attPos, i);\n//     attUv.setXY(i,\n//       (vec3.x - box.min.x) / size.x,\n//       (vec3.y - box.min.y) / size.y\n//     );\n//   }\n//   const points = mesh.geometry.get\n//\n// // turn vectors' values to a typed array\n//   const bufferPoints: number[] = [];\n//   points.slice().forEach( p => {\n//     bufferPoints.push(p.x, p.y, p.z);\n//   });\n//   const F32A = new Float32Array(bufferPoints);\n//   attPos.set(F32A, 0);\n// }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}