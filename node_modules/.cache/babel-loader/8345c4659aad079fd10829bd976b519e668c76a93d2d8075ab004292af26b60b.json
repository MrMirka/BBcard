{"ast":null,"code":"/* eslint-disable */\nimport { ExtrudeGeometry, Shape, ShapeGeometry } from 'three';\nexport class RoundedCubeGeometry extends ExtrudeGeometry {\n  constructor(width, height, depth, radius0, radius1, smoothness) {\n    const shape = new Shape();\n    const eps = 0.00001;\n    const radius = radius0 - eps;\n    shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);\n    shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);\n    shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);\n    shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);\n    super(shape, {\n      depth: depth - radius1 * 2,\n      bevelEnabled: true,\n      bevelSegments: smoothness * 2,\n      steps: 1,\n      bevelSize: radius,\n      bevelThickness: radius1,\n      curveSegments: smoothness\n    });\n    this.center();\n  }\n}\nexport class RoundedPlaneGeometry extends ShapeGeometry {\n  constructor(width, height, radius, x = (1 - width) / 2, y = 0) {\n    // const x = -width / 2;\n    // const y = -height / 2;\n\n    const shape = new Shape();\n    shape.moveTo(x, y + radius);\n    shape.lineTo(x, y + height - radius);\n    shape.quadraticCurveTo(x, y + height, x + radius, y + height);\n    shape.lineTo(x + width - radius, y + height);\n    shape.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);\n    shape.lineTo(x + width, y + radius);\n    shape.quadraticCurveTo(x + width, y, x + width - radius, y);\n    shape.lineTo(x + radius, y);\n    shape.quadraticCurveTo(x, y, x, y + radius);\n    super(shape);\n  }\n}\n\n// export const transformUV = (mesh: Mesh) => {\n//   const box = new Box3().setFromObject(mesh);\n//   const size = new Vector3();\n//   box.getSize(size);\n//   const vec3 = new Vector3(); // temp vector\n//   const attPos = mesh.geometry.attributes.position as BufferAttribute;\n//   const attUv = mesh.geometry.attributes.uv as BufferAttribute;\n//   for (let i = 0; i < attPos.count; i++){\n//     vec3.fromBufferAttribute(attPos, i);\n//     attUv.setXY(i,\n//       (vec3.x - box.min.x) / size.x,\n//       (vec3.y - box.min.y) / size.y\n//     );\n//   }\n//   const points = mesh.geometry.get\n//\n// // turn vectors' values to a typed array\n//   const bufferPoints: number[] = [];\n//   points.slice().forEach( p => {\n//     bufferPoints.push(p.x, p.y, p.z);\n//   });\n//   const F32A = new Float32Array(bufferPoints);\n//   attPos.set(F32A, 0);\n// }","map":{"version":3,"names":["ExtrudeGeometry","Shape","ShapeGeometry","RoundedCubeGeometry","constructor","width","height","depth","radius0","radius1","smoothness","shape","eps","radius","absarc","Math","PI","bevelEnabled","bevelSegments","steps","bevelSize","bevelThickness","curveSegments","center","RoundedPlaneGeometry","x","y","moveTo","lineTo","quadraticCurveTo"],"sources":["/Users/fredgan/Documents/Projects/BetBoom/Card/card/src/CardBox/instance/Rounded.ts"],"sourcesContent":["/* eslint-disable */\nimport {ExtrudeGeometry, Shape, ShapeGeometry} from 'three';\n\n\nexport class RoundedCubeGeometry extends ExtrudeGeometry {\n  constructor(width: number, height: number, depth: number, radius0: number, radius1: number, smoothness: number) {\n    const shape = new Shape();\n    const eps = 0.00001;\n    const radius = radius0 - eps;\n\n    shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);\n    shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);\n    shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);\n    shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);\n\n    super(shape, {\n      depth: depth - radius1 * 2,\n      bevelEnabled: true,\n      bevelSegments: smoothness * 2,\n      steps: 1,\n      bevelSize: radius,\n      bevelThickness: radius1,\n      curveSegments: smoothness\n    });\n\n    this.center();\n  }\n}\n\nexport class RoundedPlaneGeometry extends ShapeGeometry{\n  constructor(width: number, height: number, radius: number, x = (1 - width) / 2, y = 0) {\n    // const x = -width / 2;\n    // const y = -height / 2;\n\n    const shape = new Shape();\n    shape.moveTo( x, y + radius );\n    shape.lineTo( x, y + height - radius );\n    shape.quadraticCurveTo( x, y + height, x + radius, y + height );\n    shape.lineTo( x + width - radius, y + height );\n    shape.quadraticCurveTo( x + width, y + height, x + width, y + height - radius );\n    shape.lineTo( x + width, y + radius );\n    shape.quadraticCurveTo( x + width, y, x + width - radius, y );\n    shape.lineTo( x + radius, y );\n    shape.quadraticCurveTo( x, y, x, y + radius );\n\n    super(shape);\n  }\n}\n\n// export const transformUV = (mesh: Mesh) => {\n//   const box = new Box3().setFromObject(mesh);\n//   const size = new Vector3();\n//   box.getSize(size);\n//   const vec3 = new Vector3(); // temp vector\n//   const attPos = mesh.geometry.attributes.position as BufferAttribute;\n//   const attUv = mesh.geometry.attributes.uv as BufferAttribute;\n//   for (let i = 0; i < attPos.count; i++){\n//     vec3.fromBufferAttribute(attPos, i);\n//     attUv.setXY(i,\n//       (vec3.x - box.min.x) / size.x,\n//       (vec3.y - box.min.y) / size.y\n//     );\n//   }\n//   const points = mesh.geometry.get\n//\n// // turn vectors' values to a typed array\n//   const bufferPoints: number[] = [];\n//   points.slice().forEach( p => {\n//     bufferPoints.push(p.x, p.y, p.z);\n//   });\n//   const F32A = new Float32Array(bufferPoints);\n//   attPos.set(F32A, 0);\n// }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}